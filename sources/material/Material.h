#ifndef MATERIAL_H
#define MATERIAL_H

#include "MaterialInterface.h"
#include "Shader.h"
#include "TextureGroup.h"

/**
 * @file Material.h
 * Material implementation
 */

/**
 * @brief Material class implementation
 * Used for the real time renderer
 */
class GLMaterial : public MaterialInterface {
 public:
  enum BLENDFUNC : unsigned {
    ZERO = GL_ZERO,
    ONE = GL_ONE,
    SOURCE_ALPHA = GL_SRC_ALPHA,
    ONE_MINUS_SOURCE_ALPHA = GL_ONE_MINUS_SRC_ALPHA,
    DEST_ALPHA = GL_DST_ALPHA,
    ONE_MINUS_DEST_ALPHA = GL_ONE_MINUS_DST_ALPHA,
    CSTE_COLOR = GL_CONSTANT_COLOR,
    ONE_MINUS_CSTE_COLOR = GL_ONE_MINUS_CONSTANT_COLOR,
    CSTE_ALPHA = GL_CONSTANT_ALPHA,
    ONE_MINUS_CSTE_ALPHA = GL_ONE_MINUS_CONSTANT_ALPHA
  };

 protected:
  TextureGroup textures_group{}; /**<A structure of every type of texture to be bound*/
  float dielectric_factor{};     /**<Metallic factor : 0.0 = full dielectric , 1.0 = full metallic*/
  float roughness_factor{};      /**<Roughness factor : 0.0 = smooth , 1.0 = rough*/
  float transmission_factor{};   /**<Defines amount of light transmitted through the surface*/
  float emissive_factor{};       /**<Defines the amount of light generated by the material*/
  float shininess{};             /**<Defines the specular reflection strength*/
  float alpha_factor{};
  glm::vec2 refractive_index{};
  Shader *shader_program{};
  bool is_transparent{};

 public:
  GLMaterial();
  ~GLMaterial() override = default;
  GLMaterial(const GLMaterial &copy);
  GLMaterial(GLMaterial &&move) noexcept;
  GLMaterial &operator=(const GLMaterial &copy);
  GLMaterial &operator=(GLMaterial &&move) noexcept;
  void addTexture(int texture_database_index) override;
  virtual void bind();
  virtual void unbind();
  void clean() override;
  void initializeMaterial() override;
  void setRefractiveIndexValue(float n1, float n2) override;
  virtual void enableBlend();
  virtual void disableBlend();
  virtual void setBlendFunc(BLENDFUNC source_factor, BLENDFUNC dest_factor);
  void syncTransparencyState();
  void setEmissiveFactor(float factor) override { emissive_factor = factor; }
  void setAlphaFactor(float transparency_value) override { alpha_factor = 1.f - transparency_value; }
  virtual void setShaderPointer(Shader *shader) { shader_program = shader; }
  [[nodiscard]] bool isTransparent() const override;
  [[nodiscard]] const TextureGroup &getTextureGroup() const override { return textures_group; }
  [[nodiscard]] TextureGroup &getTextureGroupRef() { return textures_group; }
  [[nodiscard]] float getDielectricFactor() const override { return dielectric_factor; }
  [[nodiscard]] float getRoughnessFactor() const override { return roughness_factor; }
  [[nodiscard]] float getTransmissionFactor() const override { return transmission_factor; }
  [[nodiscard]] float getEmissiveFactor() const override { return emissive_factor; }
  [[nodiscard]] float getAlphaFactor() const override { return alpha_factor; }
  [[nodiscard]] Vec2f getRefractiveIndex() const override;
  [[nodiscard]] Shader *getShaderProgram() const { return shader_program; }
  [[nodiscard]] bool hasTextures() const override { return !textures_group.isEmpty(); }

 private:
  void do_copy_constr(const GLMaterial &copy);
  void do_move_constr(GLMaterial &&move) noexcept;
};

#endif
